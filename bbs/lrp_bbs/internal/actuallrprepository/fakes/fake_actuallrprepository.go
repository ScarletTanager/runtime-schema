// This file was generated by counterfeiter
package fakes

import (
	"sync"

	"github.com/cloudfoundry-incubator/runtime-schema/bbs/lrp_bbs/internal/actuallrprepository"
	"github.com/cloudfoundry-incubator/runtime-schema/models"
	"github.com/pivotal-golang/lager"
)

type FakeActualLRPRepository struct {
	ActualLRPsByProcessGuidStub        func(logger lager.Logger, processGuid string) (models.ActualLRPsByIndex, error)
	actualLRPsByProcessGuidMutex       sync.RWMutex
	actualLRPsByProcessGuidArgsForCall []struct {
		logger      lager.Logger
		processGuid string
	}
	actualLRPsByProcessGuidReturns struct {
		result1 models.ActualLRPsByIndex
		result2 error
	}
	ActualLRPWithIndexStub        func(logger lager.Logger, processGuid string, index int) (*models.ActualLRP, uint64, error)
	actualLRPWithIndexMutex       sync.RWMutex
	actualLRPWithIndexArgsForCall []struct {
		logger      lager.Logger
		processGuid string
		index       int
	}
	actualLRPWithIndexReturns struct {
		result1 *models.ActualLRP
		result2 uint64
		result3 error
	}
	CreateRawActualLRPStub        func(logger lager.Logger, lrp *models.ActualLRP) error
	createRawActualLRPMutex       sync.RWMutex
	createRawActualLRPArgsForCall []struct {
		logger lager.Logger
		lrp    *models.ActualLRP
	}
	createRawActualLRPReturns struct {
		result1 error
	}
	CompareAndSwapRawActualLRPStub        func(logger lager.Logger, lrp *models.ActualLRP, storeIndex uint64) error
	compareAndSwapRawActualLRPMutex       sync.RWMutex
	compareAndSwapRawActualLRPArgsForCall []struct {
		logger     lager.Logger
		lrp        *models.ActualLRP
		storeIndex uint64
	}
	compareAndSwapRawActualLRPReturns struct {
		result1 error
	}
	CompareAndDeleteRawActualLRPKeyStub        func(logger lager.Logger, lrp *models.ActualLRPKey, storeIndex uint64) error
	compareAndDeleteRawActualLRPKeyMutex       sync.RWMutex
	compareAndDeleteRawActualLRPKeyArgsForCall []struct {
		logger     lager.Logger
		lrp        *models.ActualLRPKey
		storeIndex uint64
	}
	compareAndDeleteRawActualLRPKeyReturns struct {
		result1 error
	}
	DeleteRawActualLRPKeyStub        func(logger lager.Logger, lrp *models.ActualLRPKey) error
	deleteRawActualLRPKeyMutex       sync.RWMutex
	deleteRawActualLRPKeyArgsForCall []struct {
		logger lager.Logger
		lrp    *models.ActualLRPKey
	}
	deleteRawActualLRPKeyReturns struct {
		result1 error
	}
	CreateActualLRPStub        func(logger lager.Logger, desiredLRP models.DesiredLRP, index int) error
	createActualLRPMutex       sync.RWMutex
	createActualLRPArgsForCall []struct {
		logger     lager.Logger
		desiredLRP models.DesiredLRP
		index      int
	}
	createActualLRPReturns struct {
		result1 error
	}
	CreateActualLRPsForDesiredStub        func(logger lager.Logger, lrp models.DesiredLRP, indices []uint) []uint
	createActualLRPsForDesiredMutex       sync.RWMutex
	createActualLRPsForDesiredArgsForCall []struct {
		logger  lager.Logger
		lrp     models.DesiredLRP
		indices []uint
	}
	createActualLRPsForDesiredReturns struct {
		result1 []uint
	}
}

func (fake *FakeActualLRPRepository) ActualLRPsByProcessGuid(logger lager.Logger, processGuid string) (models.ActualLRPsByIndex, error) {
	fake.actualLRPsByProcessGuidMutex.Lock()
	fake.actualLRPsByProcessGuidArgsForCall = append(fake.actualLRPsByProcessGuidArgsForCall, struct {
		logger      lager.Logger
		processGuid string
	}{logger, processGuid})
	fake.actualLRPsByProcessGuidMutex.Unlock()
	if fake.ActualLRPsByProcessGuidStub != nil {
		return fake.ActualLRPsByProcessGuidStub(logger, processGuid)
	} else {
		return fake.actualLRPsByProcessGuidReturns.result1, fake.actualLRPsByProcessGuidReturns.result2
	}
}

func (fake *FakeActualLRPRepository) ActualLRPsByProcessGuidCallCount() int {
	fake.actualLRPsByProcessGuidMutex.RLock()
	defer fake.actualLRPsByProcessGuidMutex.RUnlock()
	return len(fake.actualLRPsByProcessGuidArgsForCall)
}

func (fake *FakeActualLRPRepository) ActualLRPsByProcessGuidArgsForCall(i int) (lager.Logger, string) {
	fake.actualLRPsByProcessGuidMutex.RLock()
	defer fake.actualLRPsByProcessGuidMutex.RUnlock()
	return fake.actualLRPsByProcessGuidArgsForCall[i].logger, fake.actualLRPsByProcessGuidArgsForCall[i].processGuid
}

func (fake *FakeActualLRPRepository) ActualLRPsByProcessGuidReturns(result1 models.ActualLRPsByIndex, result2 error) {
	fake.ActualLRPsByProcessGuidStub = nil
	fake.actualLRPsByProcessGuidReturns = struct {
		result1 models.ActualLRPsByIndex
		result2 error
	}{result1, result2}
}

func (fake *FakeActualLRPRepository) ActualLRPWithIndex(logger lager.Logger, processGuid string, index int) (*models.ActualLRP, uint64, error) {
	fake.actualLRPWithIndexMutex.Lock()
	fake.actualLRPWithIndexArgsForCall = append(fake.actualLRPWithIndexArgsForCall, struct {
		logger      lager.Logger
		processGuid string
		index       int
	}{logger, processGuid, index})
	fake.actualLRPWithIndexMutex.Unlock()
	if fake.ActualLRPWithIndexStub != nil {
		return fake.ActualLRPWithIndexStub(logger, processGuid, index)
	} else {
		return fake.actualLRPWithIndexReturns.result1, fake.actualLRPWithIndexReturns.result2, fake.actualLRPWithIndexReturns.result3
	}
}

func (fake *FakeActualLRPRepository) ActualLRPWithIndexCallCount() int {
	fake.actualLRPWithIndexMutex.RLock()
	defer fake.actualLRPWithIndexMutex.RUnlock()
	return len(fake.actualLRPWithIndexArgsForCall)
}

func (fake *FakeActualLRPRepository) ActualLRPWithIndexArgsForCall(i int) (lager.Logger, string, int) {
	fake.actualLRPWithIndexMutex.RLock()
	defer fake.actualLRPWithIndexMutex.RUnlock()
	return fake.actualLRPWithIndexArgsForCall[i].logger, fake.actualLRPWithIndexArgsForCall[i].processGuid, fake.actualLRPWithIndexArgsForCall[i].index
}

func (fake *FakeActualLRPRepository) ActualLRPWithIndexReturns(result1 *models.ActualLRP, result2 uint64, result3 error) {
	fake.ActualLRPWithIndexStub = nil
	fake.actualLRPWithIndexReturns = struct {
		result1 *models.ActualLRP
		result2 uint64
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeActualLRPRepository) CreateRawActualLRP(logger lager.Logger, lrp *models.ActualLRP) error {
	fake.createRawActualLRPMutex.Lock()
	fake.createRawActualLRPArgsForCall = append(fake.createRawActualLRPArgsForCall, struct {
		logger lager.Logger
		lrp    *models.ActualLRP
	}{logger, lrp})
	fake.createRawActualLRPMutex.Unlock()
	if fake.CreateRawActualLRPStub != nil {
		return fake.CreateRawActualLRPStub(logger, lrp)
	} else {
		return fake.createRawActualLRPReturns.result1
	}
}

func (fake *FakeActualLRPRepository) CreateRawActualLRPCallCount() int {
	fake.createRawActualLRPMutex.RLock()
	defer fake.createRawActualLRPMutex.RUnlock()
	return len(fake.createRawActualLRPArgsForCall)
}

func (fake *FakeActualLRPRepository) CreateRawActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRP) {
	fake.createRawActualLRPMutex.RLock()
	defer fake.createRawActualLRPMutex.RUnlock()
	return fake.createRawActualLRPArgsForCall[i].logger, fake.createRawActualLRPArgsForCall[i].lrp
}

func (fake *FakeActualLRPRepository) CreateRawActualLRPReturns(result1 error) {
	fake.CreateRawActualLRPStub = nil
	fake.createRawActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeActualLRPRepository) CompareAndSwapRawActualLRP(logger lager.Logger, lrp *models.ActualLRP, storeIndex uint64) error {
	fake.compareAndSwapRawActualLRPMutex.Lock()
	fake.compareAndSwapRawActualLRPArgsForCall = append(fake.compareAndSwapRawActualLRPArgsForCall, struct {
		logger     lager.Logger
		lrp        *models.ActualLRP
		storeIndex uint64
	}{logger, lrp, storeIndex})
	fake.compareAndSwapRawActualLRPMutex.Unlock()
	if fake.CompareAndSwapRawActualLRPStub != nil {
		return fake.CompareAndSwapRawActualLRPStub(logger, lrp, storeIndex)
	} else {
		return fake.compareAndSwapRawActualLRPReturns.result1
	}
}

func (fake *FakeActualLRPRepository) CompareAndSwapRawActualLRPCallCount() int {
	fake.compareAndSwapRawActualLRPMutex.RLock()
	defer fake.compareAndSwapRawActualLRPMutex.RUnlock()
	return len(fake.compareAndSwapRawActualLRPArgsForCall)
}

func (fake *FakeActualLRPRepository) CompareAndSwapRawActualLRPArgsForCall(i int) (lager.Logger, *models.ActualLRP, uint64) {
	fake.compareAndSwapRawActualLRPMutex.RLock()
	defer fake.compareAndSwapRawActualLRPMutex.RUnlock()
	return fake.compareAndSwapRawActualLRPArgsForCall[i].logger, fake.compareAndSwapRawActualLRPArgsForCall[i].lrp, fake.compareAndSwapRawActualLRPArgsForCall[i].storeIndex
}

func (fake *FakeActualLRPRepository) CompareAndSwapRawActualLRPReturns(result1 error) {
	fake.CompareAndSwapRawActualLRPStub = nil
	fake.compareAndSwapRawActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeActualLRPRepository) CompareAndDeleteRawActualLRPKey(logger lager.Logger, lrp *models.ActualLRPKey, storeIndex uint64) error {
	fake.compareAndDeleteRawActualLRPKeyMutex.Lock()
	fake.compareAndDeleteRawActualLRPKeyArgsForCall = append(fake.compareAndDeleteRawActualLRPKeyArgsForCall, struct {
		logger     lager.Logger
		lrp        *models.ActualLRPKey
		storeIndex uint64
	}{logger, lrp, storeIndex})
	fake.compareAndDeleteRawActualLRPKeyMutex.Unlock()
	if fake.CompareAndDeleteRawActualLRPKeyStub != nil {
		return fake.CompareAndDeleteRawActualLRPKeyStub(logger, lrp, storeIndex)
	} else {
		return fake.compareAndDeleteRawActualLRPKeyReturns.result1
	}
}

func (fake *FakeActualLRPRepository) CompareAndDeleteRawActualLRPKeyCallCount() int {
	fake.compareAndDeleteRawActualLRPKeyMutex.RLock()
	defer fake.compareAndDeleteRawActualLRPKeyMutex.RUnlock()
	return len(fake.compareAndDeleteRawActualLRPKeyArgsForCall)
}

func (fake *FakeActualLRPRepository) CompareAndDeleteRawActualLRPKeyArgsForCall(i int) (lager.Logger, *models.ActualLRPKey, uint64) {
	fake.compareAndDeleteRawActualLRPKeyMutex.RLock()
	defer fake.compareAndDeleteRawActualLRPKeyMutex.RUnlock()
	return fake.compareAndDeleteRawActualLRPKeyArgsForCall[i].logger, fake.compareAndDeleteRawActualLRPKeyArgsForCall[i].lrp, fake.compareAndDeleteRawActualLRPKeyArgsForCall[i].storeIndex
}

func (fake *FakeActualLRPRepository) CompareAndDeleteRawActualLRPKeyReturns(result1 error) {
	fake.CompareAndDeleteRawActualLRPKeyStub = nil
	fake.compareAndDeleteRawActualLRPKeyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeActualLRPRepository) DeleteRawActualLRPKey(logger lager.Logger, lrp *models.ActualLRPKey) error {
	fake.deleteRawActualLRPKeyMutex.Lock()
	fake.deleteRawActualLRPKeyArgsForCall = append(fake.deleteRawActualLRPKeyArgsForCall, struct {
		logger lager.Logger
		lrp    *models.ActualLRPKey
	}{logger, lrp})
	fake.deleteRawActualLRPKeyMutex.Unlock()
	if fake.DeleteRawActualLRPKeyStub != nil {
		return fake.DeleteRawActualLRPKeyStub(logger, lrp)
	} else {
		return fake.deleteRawActualLRPKeyReturns.result1
	}
}

func (fake *FakeActualLRPRepository) DeleteRawActualLRPKeyCallCount() int {
	fake.deleteRawActualLRPKeyMutex.RLock()
	defer fake.deleteRawActualLRPKeyMutex.RUnlock()
	return len(fake.deleteRawActualLRPKeyArgsForCall)
}

func (fake *FakeActualLRPRepository) DeleteRawActualLRPKeyArgsForCall(i int) (lager.Logger, *models.ActualLRPKey) {
	fake.deleteRawActualLRPKeyMutex.RLock()
	defer fake.deleteRawActualLRPKeyMutex.RUnlock()
	return fake.deleteRawActualLRPKeyArgsForCall[i].logger, fake.deleteRawActualLRPKeyArgsForCall[i].lrp
}

func (fake *FakeActualLRPRepository) DeleteRawActualLRPKeyReturns(result1 error) {
	fake.DeleteRawActualLRPKeyStub = nil
	fake.deleteRawActualLRPKeyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeActualLRPRepository) CreateActualLRP(logger lager.Logger, desiredLRP models.DesiredLRP, index int) error {
	fake.createActualLRPMutex.Lock()
	fake.createActualLRPArgsForCall = append(fake.createActualLRPArgsForCall, struct {
		logger     lager.Logger
		desiredLRP models.DesiredLRP
		index      int
	}{logger, desiredLRP, index})
	fake.createActualLRPMutex.Unlock()
	if fake.CreateActualLRPStub != nil {
		return fake.CreateActualLRPStub(logger, desiredLRP, index)
	} else {
		return fake.createActualLRPReturns.result1
	}
}

func (fake *FakeActualLRPRepository) CreateActualLRPCallCount() int {
	fake.createActualLRPMutex.RLock()
	defer fake.createActualLRPMutex.RUnlock()
	return len(fake.createActualLRPArgsForCall)
}

func (fake *FakeActualLRPRepository) CreateActualLRPArgsForCall(i int) (lager.Logger, models.DesiredLRP, int) {
	fake.createActualLRPMutex.RLock()
	defer fake.createActualLRPMutex.RUnlock()
	return fake.createActualLRPArgsForCall[i].logger, fake.createActualLRPArgsForCall[i].desiredLRP, fake.createActualLRPArgsForCall[i].index
}

func (fake *FakeActualLRPRepository) CreateActualLRPReturns(result1 error) {
	fake.CreateActualLRPStub = nil
	fake.createActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeActualLRPRepository) CreateActualLRPsForDesired(logger lager.Logger, lrp models.DesiredLRP, indices []uint) []uint {
	fake.createActualLRPsForDesiredMutex.Lock()
	fake.createActualLRPsForDesiredArgsForCall = append(fake.createActualLRPsForDesiredArgsForCall, struct {
		logger  lager.Logger
		lrp     models.DesiredLRP
		indices []uint
	}{logger, lrp, indices})
	fake.createActualLRPsForDesiredMutex.Unlock()
	if fake.CreateActualLRPsForDesiredStub != nil {
		return fake.CreateActualLRPsForDesiredStub(logger, lrp, indices)
	} else {
		return fake.createActualLRPsForDesiredReturns.result1
	}
}

func (fake *FakeActualLRPRepository) CreateActualLRPsForDesiredCallCount() int {
	fake.createActualLRPsForDesiredMutex.RLock()
	defer fake.createActualLRPsForDesiredMutex.RUnlock()
	return len(fake.createActualLRPsForDesiredArgsForCall)
}

func (fake *FakeActualLRPRepository) CreateActualLRPsForDesiredArgsForCall(i int) (lager.Logger, models.DesiredLRP, []uint) {
	fake.createActualLRPsForDesiredMutex.RLock()
	defer fake.createActualLRPsForDesiredMutex.RUnlock()
	return fake.createActualLRPsForDesiredArgsForCall[i].logger, fake.createActualLRPsForDesiredArgsForCall[i].lrp, fake.createActualLRPsForDesiredArgsForCall[i].indices
}

func (fake *FakeActualLRPRepository) CreateActualLRPsForDesiredReturns(result1 []uint) {
	fake.CreateActualLRPsForDesiredStub = nil
	fake.createActualLRPsForDesiredReturns = struct {
		result1 []uint
	}{result1}
}

var _ actuallrprepository.ActualLRPRepository = new(FakeActualLRPRepository)
